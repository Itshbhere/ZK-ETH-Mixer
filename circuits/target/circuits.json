{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"1676084356805271065","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"NulifierHash","type":{"kind":"field"},"visibility":"public"},{"name":"recipient","type":{"kind":"field"},"visibility":"public"},{"name":"Nulifier","type":{"kind":"field"},"visibility":"private"},{"name":"Secret","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_proof","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"is_even","type":{"kind":"array","length":20,"type":{"kind":"boolean"}},"visibility":"private"}],"return_type":null,"error_types":{"7987347058810299965":{"error_kind":"string","string":"Computed Merkle root does not match the expected root"},"8755862928372444164":{"error_kind":"string","string":"NulifierHash does not match"}}},"bytecode":"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","debug_symbols":"pdfNjuIwDAfwd+mZQ+zE+eBVVitUoIwqVQV1YKQVmnffFP4ucEiF6MmGjn9KUjsartW+2V6+Nm1/OH5X6z/Xaju0Xdd+bbrjrj63xz5/e/1dVfpxcx6aJn9VPT3PVad6aPpzte4vXbeqfurucvuj71Pd3+K5HvJTs6qafp9jBg9t14zZ7+pRbcql1mixtXEql9d6mqkXRr0j/6iPL/VcrmeOCQBbwyXBlgUir0sgivLJGgJ5XUOwpiTIzBpCsLqGkIq78GUhOQGQJH5QT4anUzBePtlDMvomKHFxDzO95CbA2VTsJbOwmWimG9lHbWf2yRaJmWYg+zgGy8VXQXbhu5w9hxSnc5CPzuG9jia/uKUpLO7J2VUsb0rRbbhEpaacqRcJqPfsSvVMszfcdME9dQO9D/ipp4N8AljRZrAxFQG39JKXxbc8++XXvCyeivF9LZwKTgtvhzngzbGa3cbisfJ2GguJH4xVPn/UB/c6Vn/zp3rXDi//KVVsqnXeENM98D3YvP4xOkTJ284u+9yzeSA4IEbEdI/WIBIiI1pEhyiI8Cw8C8/Cc/AcPAfPwXPwHDwHz8Fz8Bw8gSfwBJ7AE3gCT+AJPIEn8Dw8D8/D8/A8PA/Pw/PwPDwPL8AL8AK8AC/AC/ACvAAvwAvwIrwIL8KL8CK8CC/Ci/AivAgvwUvwErwEL8FL8BK8BC/BS/DIGE1IE9bEauI0EU28JkGTqInKpDKpTCqTyqQyqUwqk8qkMqnMKrPKrDKrzCqzyrfRsWMyym5MRnkc0Z96aOtt1+CXy+HS755+yJz/nfSJ/tQ5Dcdds78MzTjKt2d5uP8D","file_map":{"50":{"source":"use poseidon::poseidon2::{self, Poseidon2};\nmod merkle_tree;\nfn main(\n    root: pub Field,\n    NulifierHash: pub Field,\n    recipient: pub Field,\n    Nulifier: Field,\n    Secret: Field,\n    merkle_proof: [Field; 20],\n    is_even: [bool; 20],\n) {\n    //Calculate Comitment\n    let Commitment: Field = Poseidon2::hash([Nulifier, Secret], 2);\n    //Calculate NulifierHash\n    let NulifierHashCalculated: Field = Poseidon2::hash([Nulifier], 1);\n\n    assert(NulifierHashCalculated == NulifierHash, \"NulifierHash does not match\");\n\n    let Computed_root: Field = merkle_tree::compute_merkle_root(Commitment, merkle_proof, is_even);\n    assert(Computed_root == root, \"Computed Merkle root does not match the expected root\");\n\n    assert(recipient != 0); // dummy usage to silence warning\n\n}\n","path":"/home/larsa/SolanaDev/ZK_Mixer/circuits/src/main.nr"},"51":{"source":"use poseidon::poseidon2::{self, Poseidon2};\n\npub fn compute_merkle_root(leaf: Field, merkle_proof: [Field; 20], is_even: [bool; 20]) -> Field {\n    let mut hash: Field = leaf;\n    for i in 0..20 {\n        let (left, right) = if is_even[i] {\n            (hash, merkle_proof[i])\n        } else {\n            (merkle_proof[i], hash)\n        };\n        hash = Poseidon2::hash([left, right], 2);\n    }\n    hash\n}\n","path":"/home/larsa/SolanaDev/ZK_Mixer/circuits/src/merkle_tree.nr"},"58":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/larsa/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_invert"]}